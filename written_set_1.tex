\documentclass{article}
\usepackage{enumerate}

\title{Written Set 2: Parsing}
\author{Prakash Surya\\\\CS 143 - Compilers - Keith Schwarz}
\date{\today}

\begin{document}
\maketitle

\section{Problem 1: LL(1)}

\begin{enumerate}[i.]
	\item Compute the FIRST sets for each of the nonterminals in this
		grammar. Show your result.
		\begin{enumerate}
			\item FIRST(J) = $\epsilon$, , (an actual comma)
			\item FIRST(I) = identifier
			\item FIRST(Y) = $\epsilon$, implements
			\item FIRST(X) = $\epsilon$, extends
			\item FIRST(F) = $\epsilon$, final
			\item FIRST(P) = $\epsilon$, public
			\item FIRST(C) = FIRST(P) $\cup$ FIRST(F) $\cup$ class
			               = public, final, class
			\item FIRST(S) = FIRST(C) = public, final, class
		\end{enumerate}
	\item Compute the FOLLOW sets for each of the nonterminals in this
		grammar. Show your result.
		\begin{enumerate}
			\item FOLLOW(S) = \$
			\item FOLLOW(C) = \$
			\item FOLLOW(P) = FIRST(F) $\cup$ class
			                = final, class
			\item FOLLOW(F) = class
			\item FOLLOW(X) = FIRST(Y) $\cup$ FOLLOW(C)
			                = implements, \$
			\item FOLLOW(Y) = FOLLOW(C) = \$
			\item FOLLOW(I) = FOLLOW(Y) = \$
			\item FOLLOW(J) = FOLLOW(I) = \$
		\end{enumerate}
	\item Using your results from (i) and (ii), construct the LL(1) parser
		table for this grammar. When indicating which productions should
		be performed, please use our numbering system from above. Show
		your result.

		\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
			                                                                            \hline
			  & public & final & class & identifier & extends & implements &  , & \$ \\ \hline
			S &    1   &   1   &   1   &            &         &            &    &    \\ \hline
			C &    2   &   2   &   2   &            &         &            &    &    \\ \hline
			P &    3   &   4   &   4   &            &         &            &    &    \\ \hline
			F &        &   5   &   6   &            &         &            &    &    \\ \hline
			X &        &       &       &            &    7    &      8     &    &    \\ \hline
			Y &        &       &       &            &    7    &      9     &    & 10 \\ \hline
			I &        &       &       &     11     &         &            &    &    \\ \hline
			J &        &       &       &            &         &            & 12 & 13 \\ \hline
		\end{tabular}
\end{enumerate}

\section{Problem 2: LL(k)}

\begin{enumerate}[i.]
	\item Give an example of a grammar that is LL(2) but not LL(1). You
		must explain why your grammar meets these criteria, but you don't
		need to formally prove it.

		The following example grammar is LL(2) but not LL(1):
		\begin{enumerate}[(1)]
			\item S $\to$ E
			\item E $\to$ T + T
			\item E $\to$ T - T
			\item T $\to$ int
		\end{enumerate}

		The above grammar is not LL(1) because with just a single token
		of lookahead, the expansion of E is ambiguous. A parser cannot
		uniquely predict whether E should expand out to T + T or T - T.
		For example, given the string: `int + int', an LL(1) parser
		would expand S $\to$ E, but given it can only ``see'' the int
		terminal, it cannot uniquely determine what E should expand out
		to. Is it T + T, or T - T?

		An LL(2) predictive parser, on the other hand, will ``see'' the
		int along with the + symbol. Thus, the LL(2) parser can
		uniquely determine that E should expand out to T + T in this
		case. Then T $\to$ int, + $\to$ +, and finally T $\to$ int
		again.

		Essentially, this grammar \emph{is not} LL(1) because E can
		expand out to two different productions, and each of these
		productions have a common single token prefix. Although, this
		grammar \emph{is} LL(2) because the two token prefixes for E
		are unique (i.e. `int +' and `int -').

	\item Prove that any LL(1) grammar is LL(2)

		% TODO: Add solution
\end{enumerate}

\section{Problem 3: LL(0)}

\begin{enumerate}
	\item Describe the set of grammars that can be parsed with an LL(0)
		parser. As a hint, LL(0) is an extremely weak method, and is
		never used in compilers.

		An LL(0) grammar is a grammar that can be parsed without ever
		looking at any lookahead tokens. Each nonterminal has to be
		able to be uniquely expanded out without knowing what the next
		token will be. Because of this, each nonterminal can
		essentially only have a single production associated with it.
		This is because without any tokens of lookahead, an LL(0) parser
		cannot make a decision on how to expand a given nonterminal if
		it has multiple productions associated with it. For example, the
		following grammar is LL(0):
		\begin{enumerate}[(1)]
			\item S $\to$ A
			\item A $\to$ B C
			\item B $\to$ class
			\item C $\to$ identifier
		\end{enumerate}
		because each nonterminal can only be expanded out in a single
		way. Thus, the fact that lookahead tokens are unnecessary to
		uniquely expand out a nonterminal allow this grammar to be
		LL(0).
\end{enumerate}

\section{Problem 4: Left Factoring}

\begin{enumerate}[i.]
	\item Explain, at a high level, why many grammars that are
		left-factorable are not LL(1).

		Many grammars that are left-factorable are not LL(1) because
		they often contain nonterminals which can expand out to multiple
		productions that share a common prefix. For example, in the
		following:
		\begin{enumerate}[(1)]
			\item A $\to$ E + T
			\item A $\to$ E
		\end{enumerate}
		both productions for A share the common prefix of E. Thus, if
		an LL(1) parser has an A, and it's lookahead is in FIRST(E),
		it has no way to decide whether it should expand A $\to$ E + T
		or A $\to$ E.

	\item Give an example of a grammar that is left-factorable but is still
		LL(1). Make sure to explain why your grammar is LL(1).

		% TODO: Add solution

	\item Give an example of a grammar that is left-factorable that is
		LL(2) but not LL(1). Make sure to explain why your grammar
		meets these criteria.

		The following grammar is LL(2) but not LL(1):
		\begin{enumerate}[(1)]
			\item S $\to$ E
			\item E $\to$ T + T
			\item E $\to$ T - T
			\item T $\to$ int
		\end{enumerate}
		This grammar is not LL(1) because E can expand to two different
		productions that share a common prefix. When the parsers has an
		E, and the lookahead is an int, it cannot tell which production
		to use to expand E. Although the grammar is not LL(1), it is
		LL(2). This is because at the same point where the LL(1) parser
		would become confused, the extra lookahead token an LL(2)
		parser has clears this ambiguity. Now the parser will either
		have the lookahead of `int +' or `int -' and be able to
		unambiguously determine which production should be expanded.

		This grammar is also left-factorable as the E productions could
		be factored like so:
		\begin{enumerate}[(1)]
			\item S $\to$ E
			\item E $\to$ TQ
			\item Q $\to$ + T
			\item Q $\to$ - T
			\item T $\to$ int
		\end{enumerate}
\end{enumerate}

\section{Problem 5: SLR(1) Parsing}

Below is a context-free grammar for strings of balanced parentheses:
\begin{enumerate}[(1)]
	\item S $\to$ P
	\item P $\to$ (P)P
	\item P $\to$ $\epsilon$
\end{enumerate}

\begin{enumerate}[i.]
	\item Construct the LR(0) configurating sets for this grammar. Show
		your result. As a hint, there are six total configurating sets.
		Note that when dealing with the production P $\to$ $\epsilon$,
		there is only one LR(0) item, which is P $\to$ $\cdot$

		\begin{enumerate}[(1)]
			\item \begin{enumerate}[]
				\item S $\to$ $\cdot$ P
				\item P $\to$ $\cdot$ (P)P
				\item P $\to$ $\cdot$
			\end{enumerate}

			\item \begin{enumerate}[]
				\item S $\to$ P $\cdot$
			\end{enumerate}

			\item \begin{enumerate}[]
				\item P $\to$ ( $\cdot$ P)P
				\item P $\to$ $\cdot$ (P)P
				\item P $\to$ $\cdot$
			\end{enumerate}

			\item \begin{enumerate}[]
				\item P $\to$ (P $\cdot$ )P
			\end{enumerate}

			\item \begin{enumerate}[]
				\item P $\to$ (P) $\cdot$ P
				\item P $\to$ $\cdot$ (P)P
				\item P $\to$ $\cdot$
			\end{enumerate}

			\item \begin{enumerate}[]
				\item P $\to$ (P)P $\cdot$
			\end{enumerate}
		\end{enumerate}
\end{enumerate}

\end{document}
