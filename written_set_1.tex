\documentclass{article}
\usepackage{enumerate}

\title{Written Set 2: Parsing}
\author{Prakash Surya\\\\CS 143 - Compilers - Keith Schwarz}
\date{\today}

\begin{document}
\maketitle

\section{Problem 1: LL(1)}

\begin{enumerate}[i.]
	\item Compute the FIRST sets for each of the nonterminals in this
		grammar. Show your result.
		\begin{enumerate}
			\item FIRST(J) = $\epsilon$, , (an actual comma)
			\item FIRST(I) = identifier
			\item FIRST(Y) = $\epsilon$, implements
			\item FIRST(X) = $\epsilon$, extends
			\item FIRST(F) = $\epsilon$, final
			\item FIRST(P) = $\epsilon$, public
			\item FIRST(C) = FIRST(P) $\cup$ FIRST(F) $\cup$ class
			               = public, final, class
			\item FIRST(S) = FIRST(C) = public, final, class
		\end{enumerate}
	\item Compute the FOLLOW sets for each of the nonterminals in this
		grammar. Show your result.
		\begin{enumerate}
			\item FOLLOW(S) = \$
			\item FOLLOW(C) = \$
			\item FOLLOW(P) = FIRST(F) $\cup$ class
			                = final, class
			\item FOLLOW(F) = class
			\item FOLLOW(X) = FIRST(Y) $\cup$ FOLLOW(C)
			                = implements, \$
			\item FOLLOW(Y) = FOLLOW(C) = \$
			\item FOLLOW(I) = FOLLOW(Y) = \$
			\item FOLLOW(J) = FOLLOW(I) = \$
		\end{enumerate}
	\item Using your results from (i) and (ii), construct the LL(1) parser
		table for this grammar. When indicating which productions should
		be performed, please use our numbering system from above. Show
		your result.

		\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
			                                                                            \hline
			  & public & final & class & identifier & extends & implements &  , & \$ \\ \hline
			S &    1   &   1   &   1   &            &         &            &    &    \\ \hline
			C &    2   &   2   &   2   &            &         &            &    &    \\ \hline
			P &    3   &   4   &   4   &            &         &            &    &    \\ \hline
			F &        &   5   &   6   &            &         &            &    &    \\ \hline
			X &        &       &       &            &    7    &      8     &    &    \\ \hline
			Y &        &       &       &            &    7    &      9     &    & 10 \\ \hline
			I &        &       &       &     11     &         &            &    &    \\ \hline
			J &        &       &       &            &         &            & 12 & 13 \\ \hline
		\end{tabular}
\end{enumerate}

\section{Problem 2: LL(k)}

\begin{enumerate}[i.]
	\item Give an example of a grammar that is LL(2) but not LL(1). You
		must explain why your grammar meets these criteria, but you don't
		need to formally prove it.

		The following example grammar is LL(2) but not LL(1):
		\begin{enumerate}[(1)]
			\item S $\to$ E
			\item E $\to$ T + T
			\item E $\to$ T - T
			\item T $\to$ int
		\end{enumerate}

		The above grammar is not LL(1) because with just a single token
		of lookahead, the expansion of E is ambiguous. A parser cannot
		uniquely predict whether E should expand out to T + T or T - T.
		For example, given the string: `int + int', an LL(1) parser
		would expand S $\to$ E, but given it can only ``see'' the int
		terminal, it cannot uniquely determine what E should expand out
		to. Is it T + T, or T - T?

		An LL(2) predictive parser, on the other hand, will ``see'' the
		int along with the + symbol. Thus, the LL(2) parser can
		uniquely determine that E should expand out to T + T in this
		case. Then T $\to$ int, + $\to$ +, and finally T $\to$ int
		again.

		Essentially, this grammar \emph{is not} LL(1) because E can
		expand out to two different productions, and each of these
		productions have a common single token prefix. Although, this
		grammar \emph{is} LL(2) because the two token prefixes for E
		are unique (i.e. `int +' and `int -').

	\item Prove that any LL(1) grammar is LL(2)
\end{enumerate}

\end{document}
